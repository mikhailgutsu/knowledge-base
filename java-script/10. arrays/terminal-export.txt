
--------------------------------------------------------------------------------------------
1) Arrays — literals, length, holes, Array.of/from
--------------------------------------------------------------------------------------------

▶ Creation & basics
  {
    a: [ 1, 2, 3 ],
    b: [ <3 empty items> ],
    c: [ 3 ],
    d: [ 'a', 'b', 'c' ],
    aLen: 3,
    bLen: 3
  }
  holes vs undefined: 2 1
  sparse.map(x=>x) -> [ 1, <1 empty item>, 3 ]

▶ Push/pop, shift/unshift, splice (mutating)
  after push/unshift -> [ 0, 1, 2, 3, 4 ]
  after pop/shift -> [ 1, 2, 3 ]
  after splice -> [ 1, 9, 9, 3 ]

▶ Non-mutating copies: slice, concat, toReversed/toSorted (modern)
  slice(0)     -> [ 3, 1, 2 ]
  concat([4])  -> [ 3, 1, 2, 4 ]
  toReversed  -> [ 2, 1, 3 ]
  toSorted    -> [ 1, 2, 3 ]

--------------------------------------------------------------------------------------------
2) Array Methods — transform/utils
--------------------------------------------------------------------------------------------

▶ map, filter, reduce, flat, flatMap (non-mutating)
  map *2      -> [ 2, 4, 6, 8 ]
  filter evens-> [ 2, 4 ]
  reduce sum  -> 10
  flat        -> [ 1, 2, 3 ]
  flatMap     -> [
    1, 2, 2, 4,
    3, 6, 4, 8
  ]

▶ fill, copyWithin (mutating)
  fill(0,1,4)      -> [ 1, 0, 0, 0, 5 ]
  copyWithin(0,3)  -> [ 4, 5, 3, 4, 5 ]

▶ join, toString, at, includes
  join(',')  -> a,b,c
  toString   -> a,b,c
  at(-1)     -> c
  includes('b')-> true

▶ from with map & of
  Array.from({length:5}, (_,i)=>i*i) -> [ 0, 1, 4, 9, 16 ]
  Array.of(1,'a',null) -> [ 1, 'a', null ]

--------------------------------------------------------------------------------------------
3) Search — indexOf/lastIndexOf/includes, find/findIndex/findLast
--------------------------------------------------------------------------------------------

▶ indexOf/lastIndexOf/includes (strict equality)
  indexOf(2)        -> 1
  lastIndexOf(2)    -> 3
  includes(3)       -> true

▶ find / findIndex / findLast / findLastIndex (predicate)
  find > 10         -> 12
  findIndex > 13    -> 3
  findLast < 50    -> 44
  findLastIndex <50-> 4

--------------------------------------------------------------------------------------------
4) Sort — lexical vs numeric, custom compare, stability, locale
--------------------------------------------------------------------------------------------

▶ Default sort is lexicographic on strings
  default sort -> [ 1, 10, 2, 5 ]

▶ Numeric sort with comparator (ascending/descending)
  asc -> [ 1, 2, 5, 10 ]
  desc-> [ 10, 5, 2, 1 ]

▶ Sort objects by key; stable since ES2019
  byAgeThenName -> [
    { name: 'Bob', age: 22 },
    { name: 'Alex', age: 31 },
    { name: 'Maria', age: 31 }
  ]

▶ Locale-aware string sort
  localeCompare('de') -> [ 'a', 'ä', 'z' ]

--------------------------------------------------------------------------------------------
5) Iterations — for/of, forEach vs map, some/every
--------------------------------------------------------------------------------------------

▶ for...of vs forEach vs map
  for...of -> [ 2, 4, 6 ]
  forEach -> [ 2, 4, 6 ]
  map -> [ 2, 4, 6 ]

▶ some/every for predicates
  every even -> true
  some > 5   -> true

--------------------------------------------------------------------------------------------
6) Reference & Const — shallow copy, deep copy, const, freeze
--------------------------------------------------------------------------------------------

▶ Reference semantics & shallow clone
  a[0].id -> 99 c[0].id -> 99

▶ Deep clone (structuredClone if available)
  deep[0].id stays -> 1

▶ const arrays: content is mutable; binding is not
  xs -> [ 1, 2, 3 ]
  after freeze -> [ 1, 2, 3 ]

--------------------------------------------------------------------------------------------
7) Typed Arrays — basics (ArrayBuffer, views, constructors)
--------------------------------------------------------------------------------------------

▶ Create buffer and views (Uint8Array / Int16Array / Float32Array)
  { byteLength: 8, u8Len: 8, i16Len: 4, f32Len: 2 }
  i16 view after u8 writes -> [ 513, 1027, 0, 0 ]

▶ Construct from length / array / Array.from; from normal array
  { a: [ 0, 0, 0, 0 ], b: [ 1, 4464 ], c: [ 10, 20, 30 ] }

--------------------------------------------------------------------------------------------
8) Typed Methods — set, subarray/view, slice/copy, map/filter/reduce
--------------------------------------------------------------------------------------------

▶ set (copy from array/typed array) & subarray (no copy)
  u8 -> [
    0, 0, 99, 2,
    3, 4,  0, 0
  ] view -> [ 99, 2, 3, 4 ]

▶ slice returns a copy (same type)
  u8 -> [ 1, 2, 3, 4, 5 ] copy -> [ 99, 3, 4 ]

▶ Iteration helpers exist on typed arrays too
  map *2      -> [ 2, 4, 6, 8 ]
  filter even -> [ 2, 4 ]
  reduce sum  -> 10

--------------------------------------------------------------------------------------------
9) Typed Reference — shared ArrayBuffer, DataView, endianness
--------------------------------------------------------------------------------------------

▶ Multiple views share one buffer
  u32[0] -> 305419896 (value depends on platform endianness when reinterpreting)

▶ DataView for explicit endianness reads/writes
  getUint8 bytes -> 120 86 52 18
  getUint32 LE   -> 12345678
  getUint32 BE   -> 78563412

--------------------------------------------------------------------------------------------
10) Mini practice — combine everything
--------------------------------------------------------------------------------------------

▶ Remove duplicates (Set) and stable-sort by length then lexicographically
  {
    unique: [ 'pear', 'apple', 'banana', 'fig' ],
    sorted: [ 'fig', 'pear', 'apple', 'banana' ]
  }

▶ Chunk array (size k) and flatten back
  chunks -> [ [ 1, 2, 3 ], [ 4, 5, 6 ], [ 7, 8, 9 ], [ 10 ] ]
  flatten -> [
    1, 2, 3, 4,  5,
    6, 7, 8, 9, 10
  ]

▶ Typed: copy image row into a larger buffer using set/subarray
  canvas -> [
    10, 20, 30, 40, 10,
    20, 30, 40, 10, 20,
    30, 40
  ]

--------------------------------------------------------------------------------------------
11) Takeaways
--------------------------------------------------------------------------------------------
- Arrays: choose non-mutating methods (slice/concat/map/filter) for purity; know which ones mutate.
- Search: use includes/indexOf for values; find/findIndex for predicates; findLast in modern runtimes.
- Sort: default is lexicographic; pass a comparator for numeric or custom order; sort is stable (ES2019+).
- Iteration: map returns new array; forEach is side-effect only; some/every for boolean checks.
- Reference: arrays are objects (reference semantics); shallow copies share nested objects.
- const protects the binding, not contents; freeze is shallow.
- Typed arrays share ArrayBuffers; subarray is a view (no copy); slice copies; use DataView for endianness.
